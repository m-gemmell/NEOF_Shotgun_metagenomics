# Bin quality scores
<center>
![](figures/quality_ribbon.png){style="width:150px; background: white ; border-radius: 5px; border: white solid 5px"}
</center>

One quick way to calculate the overall quality of a <u id='mag'>MAG</u>/bin is with the following equation:

$$
q = comp - (5 * cont)
$$
Where:

- __q__ = Overall quality
- __comp__ = Completeness
- __cont__ = Contamination

A score of at least 70-80% (i.e. 0.7 to 0.8) would be the aim, with a maximum/perfect value being 100% (100% completeness, 0% contamination). We'll therefore calculate this for the bins with some bash and `awk` scripting.

__Note__: Values will range from:

- 100% (i.e. 1): 1 Completeness - (5 * 0 Contamination)
- -500% (i.e. -5): 0 Completeness - (5 * 1 Contamination)

## Quality file
<center>
![](figures/header_2.png){style="width:100px; background: white ; border-radius: 5px"}
</center>

We will create a new file with only the quality information called "MAGS_quality.csv". 

Make the file with it only containing the header "quality.
We will add the quality scores to this later.

```{bash eval=FALSE}
echo "quality" > MAGS_quality.csv
```

## Calculate quality with awk
<center>
![](figures/calculator_3.png){style="width:150px; background: white ; border-radius: 5px"}
</center>

Next is the most complicated command. We will be calculating the Overall quality (see calculation above) for each row except the header row.

We will be using a complicated linux based language called `awk`. This is very useful as it can carry out calculations on columns or as `awk` calls them, __fields__.

As this is new and complicated we will build up our command step by step.

### Extract fields/columns

__The first step__ is to extract the completeness and contamination fields/columns.

```{bash eval=FALSE}
awk -F, '{print $2,$3}' cocopye_output.csv
```

- `-F,`: Indicates the input fields are separated by commas (`,`).
- `''`: All the `awk` options are contained within the quotes.
- `{}`: We can supply a function to `awk` within the braces.
- `print $2,$3`: This function instructs `awk` to print the 2nd (completeness) and 3rd (contamination) fields. It is common to put commas (`,`) between fields if printing multiple fields.
- `cocopye_output.csv`: Our last parameter is the input file. We are not changing the contents of the file, only printing information to screen/stdout.

### Ignore header

__We do not want the header__ in our calculation so we will add an extra `awk` option.

```{bash eval=FALSE}
awk -F, 'NR>1 {print $2,$3}' cocopye_output.csv
```

- `NR>1`: `NR` stands for number of records. Rows are called records in `awk`. Therefore `NR>1` means `awk` will only carry out the functions on the records numbered greater than 1. I.e. skip row 1, the header row.

### Calculate quality

__The next step__ is to carry out the overall quality calculation.

```{bash eval=FALSE}
awk -F, 'NR>1 {print $2 - (5 * $3)}' cocopye_output.csv
```

Our new function, `{print $2 - (5 * 13)}`, carries out the overall quality calculation and prints it for each record/row except the first (`NR>1`).

You will notice that we have values that equal 4.
Let us fix that.

### Fix values

Some quality values come out as 4.
This is not correct and comes about as some completeness and contamination values have been set to -1 (-1 - (5 * -1) = 4).
If you look at the file `cocopye_output.csv` you will notice the bins with -1 values have the `rejected` for their `method` value.
These are bins which failed the Input Pre-procesing step.

We will therefore change these quality values to the lowest possible value of -5 (0 - (5 * 1) = -5).

```{bash eval=FALSE}
awk -F, 'NR>1 {print $2 - (5 * $3)}' cocopye_output.csv | \
sed "s/^4$/-5/"
```

In this case we [pipe (`|`)](https://neof-workshops.github.io/Unix_nxcdf7/Course/12-Advanced_linux_practice.html#pipes) our output to [`sed`](https://neof-workshops.github.io/Unix_nxcdf7/Course/12-Advanced_linux_practice.html#sed) to substitute lines that start with (`^`) and end with (`$`) the same `4` with `-5`.

In other words we replace lines that only contain a 4 with a -5.

### Append to quality file

Finally we can append the quality values to our `MAGS_quality.csv` file.

```{bash eval=FALSE}
awk -F, 'NR>1 {print $2 - (5 * $3)}' cocopye_output.csv | \
sed "s/^4$/-5/" >> MAGS_quality.csv
```

In the above case we use `>>` to append the information to the file `MAGS_quality.csv`. We append because we want to retain the header we added to the file earlier.

You can view the file to ensure it worked. The first and second values should be 0.9838 and 0.493

```{bash eval=FALSE}
less MAGS_quality.csv
```

## Add quality to the checkm results file
<center>
![](figures/two_columns.png){style="width:150px; background: white ; border-radius: 5px"}
</center>

Now we can combine the files `cocopye_output.csv` and `MAGS_quality.csv` with the `paste` command into a new file called `cocopye_quality.csv`. The `-d ","` option indicates the merged files will be separated by commas (`,`), matching the column separation in `cocopye_output.csv`.

```{bash eval=FALSE}
paste -d "," cocopye_output.csv MAGS_quality.csv > cocopye_quality.csv
```

## MCQs
<center>
![](figures/question_bubble_blue.png){style="width:100px; background: white; border-radius: 5px; border: 5px white solid"}
</center>

Viewing the file `cocopye_output.csv` attempt the below questions.

__Tip__: You can use the `cut` command to look at specific columns. For example:

```{bash eval=FALSE}
#look at the "bin" and "quality" columns
#Convert the printed output's commas to tabs for readability
cut -d "," -f 1,8 cocopye_quality.csv | tr "," "\t"
```

```{r, echo = FALSE}
opts_p <- c("__Bacteria__", answer="__Bacteroides__", "__Lachnospiraceae__")
```
1. What lineage was assigned to bin __K1.1__? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__Bacteria__", "__Bacteroides__", answer="__Lachnospiraceae__")
```
2. What lineage was assigned to bin __K1.22__? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__Bacteria__", "__Bacteroides__", "__Lachnospiraceae__")
```
3. What lineage was assigned to bin __K1.8__? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__0.0202__", answer="__0.6724__", "__0.9769__")
```
4. What is the quality value of __K1.1__? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__0.0202__", "__0.6724__", answer="__0.9769__")
```
5. What is the completeness value of __K1.30__? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__0.0202__", "__0.6724__", "__0.9769__")
```
6. What is the contamination value of __K1.12__ bin? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__K1.20__", "__K1.26__", answer="__K1.22__")
```
7. Which bin has the highest quality value (98.38%)? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c(answer="__K1.20__", "__K1.26__", "__K1.22__")
```
8. Which bin has the quality value of -2.9215? `r longmcq(opts_p)`

```{r, echo = FALSE}
opts_p <- c("__K1.20__", answer="__K1.26__", "__K1.22__")
```
9. Which bin has the highest completeness value (98.59%)? `r longmcq(opts_p)`

## Bin quality summary
<center>
![](figures/sum_blue.png){style="width:100px; background: white ; border-radius:5px; border: 5px white solid"}
</center>

It is always useful to know the quality of your bins so you know which are more reliable than others. With that information you can be more or less certain when concluding your findings.

We have some good quality bins but many poorer quality bins too. Ultimately binning is trying to separate all the genomes from each other. A better metagenome assembly would most likely have led to better binning.

```{r, echo=FALSE}
#Tippy tooltips
tippy::tippy_this(elementId = "mag", 
                  tooltip = "Metagenome-Assembled Genome",
                  arrow = TRUE, placement = "bottom")
```