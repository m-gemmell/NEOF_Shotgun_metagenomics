# Functional annotation
```{r, fig.align = 'center',out.width= '30%', echo=FALSE }
knitr::include_graphics(path = "figures/quality_trimming_and_filtering.png", auto_pdf = TRUE)
``` 

Now that we have a set of genes/proteins predicted in our metagenomic sample, we can functionally annotate them. As always, there are a variety of methods for obtaining functional annotations (e.g. rpsBLAST vs CDD/KOG, BLASTKoala).

Today we will use an all-in-one solution called Cognizer which assigns functions inferred from mapping to COG categorisations (KEGG, COG, SEED, GO, Pfam). This framework tool was actually intended for use with reads as input rather than gene/protein sequences: It will take reads and runs a translated BLAST (BLASTP) search against a custom protein database, before determining a variety of functional annotations for each read. 

Unfortunately, this is a very processor intensive and slow process so we are cutting the workload down dramatically by instead providing the software with our predicted protein sequences. Even then, this process takes too long to complete in a tutorial session, so we will instead run the program on a subset of our data, i.e. 2000 proteins. 

To do this, we will use Seqtk (Sequence tool kit)

```{bash eval=FALSE}
seqtk sample K1.newHeaders.faa 2000 > K1.sample.faa
```

This command simply tells Seqtk to select 2000 entries from `K1.newHeaders.faa` and output them in `K1.sample.faa`. This resulting set of proteins will be much more manageable.

## Annotation types

Cognizer is a very useful tool because it assigns multiple different functional annotations in one run. Below is a brief description of these annotation types.

- __COG__: Clusters of Orthologous Groups database generated by comparing predicted and known proteins in all completely sequenced microbial genomes.
- __COG Functional Description__: Based on single letter annotation, these descriptions categorise the function of the gene/protein. A table of these can be found in the appendix of this document.
- __KEGG__: A database resource for understanding high-level functions. Annotations range from small molecules up to whole biological pathways. Today we will touch upon KEGG Orthology (KO systems) which can be used to construct KEGG pathway modules (functional units) which are part of the larger KEGG pathways.
- __Pfam__: A database comprising a large collection of protein families, each represented by multiple sequence alignments and hidden Markov models.
- __GO__: Gene Ontology database that classifies functions along three aspects: molecular function (i.e. activities of gene products), cellular function (i.e. where the gene product is active) and biological process (e.g. pathways)
- __FIG__: Set of protein sequences that are similar along their full length (not just based on a domain). All of the proteins within a single FIG family (FIGfam) are believed to implement the same function
- __SEED__: Database created in 2004 for genome annotation annotation purposes, which predicts gene function and allows for the discovery of new pathways.

## Running Cognizer
Make a new directory to store the annotations in.

```{bash eval=FALSE}
cd ..

mkdir 8-GeneAnnotations

cd 8-GeneAnnotations

cognizer_aa -d $DB/Cognizer/ -e -10 \
-i ../7-GenePredictions/K1.sample.faa -t 12 -o K1.sample
```

Here, we have asked cognizer to annotate out proteins with 12 CPUs and output any BLAST matches with an e-value of 1x10-10 or lower to an output directory named K1.sample. 

Once Cognizer has finished, see what files it has generated:

```{bash eval=FALSE}
ls K1.sample
```

You will see there are six stat files which contain the number of incidences of proteins matching an annotation from each of the above databases. The one other file, assignments.txt, contains a table showing all of the query protein sequences and the annotations found for that protein.

Have a look in some of the .stat files (e.g. cog.stat) to see what the annotations look like. Take a look at assignments.txt too to see if you can match up the columns with the annotation types

## Visualisation

Before we move on to the next part of the tutorial, we will visualise some of the functional annotations we have assigned to our metagenome. 

### COG categories

We can quickly create a graph to show the frequency of genes assigned to each of the COG categories. First, we need to tabulate and calculate the frequencies of the results which reside at the top of the K1.sample/cog.stat file.

```{bash eval=FALSE}
getCogProportions.sh K1.sample/cog.stat K1 > K1.sample.cog.tsv
```

The second argument, K1, is to tell the script the ID of the sample for graphing purpose.

We can now draw our graph:

```{bash eval=FALSE}
CogBarChart.R -i K1.sample.cog.tsv -o K1.sample.cog.pdf

okular K1.sample.cog.pdf &
```

___PLOT HERE__

The bar-plot tells us the proportion of genes belonging to each COG functional category, which you can look up in the appendix of this document., but that's not particularly informative unless we can compare it with something: We will come to this soon.

#### KEGG pathways

The above section told us the proportion of genes assigned to different COG functional categories, but nothing about the relationship between genes. To do this we will use the KEGG annotations that we obtained, but instead of just using a subset of the data, we will use annotations generated from the whole of sample K1, calculated prior to the workshop. Copy the full file over:

```{bash eval=FALSE}
cp $DB/FullAnalysis2019/8-GeneAnnotations/K1.f/assignments.txt \
K1.full.assignments.txt
```

If you take a look at the file, you will see that the first column consists of the gene/protein id, and the fourth column consists of one or more KO (KEGG orthologue) identifiers. For now, these are the only column we need so we will trim the rest away.

```{bash eval=FALSE}
getKeggFromAssignments.sh \
K1.full.assignments.txt > K1.full.kegg.tsv
```

This has created a two column file: gene id and KO id, which we can submit on the KEGG website. There, it will reconstruct functional pathways highlighting the presence or absence of the identified KEGG orthologues. Open Firefox 

```{bash eval=FALSE}
firefox &
```

and navigate to www.genome.jp/kegg/tool/map_pathway.html. Here, press the 'Browse' button and select your home directory from the right side panel ('Places'). NB: Your home directory will start with nsc. Then, select 8-GeneAnnotations â†’ K1.full.kegg.tsv, then press 'Exec'.

__PLOT HERE__

After a few moments, a long list of pathways will appear which you can click on to view. The number in brackets after the pathway shows the number of KEGG orthologue matches identified in this pathway. 

Try selecting some of the pathways and examine the pathway diagrams. Components marked in green have been identified in the sample and using this data we can identify complete and broken pathways of interest. See image below.

__PLOT HERE__

Ultimately, there is a lot of information here, but it only becomes fully useful if we can either make it more quantitative, compare it to other samples, or both. Currently, the data we have is not representative of what is in the sample beyond a qualitative measure, i.e. we know that Gene A might be present in K1, but we don't know how much of Gene A is there. Once we have this information and the same information for K2, W1, and other samples we can start making some real comparisons. This will be covered in the following section.